* Graphics programming - home exam 1
**  Description of solution
***  Limitations
***  Things I did not have time for
**  Technical challenges met during implementation
   The main challenge met during the implementation--which is likely to pop up other places in the report--was my lack of familiarity with WebGL as a whole. While I have made an effort to stay up to date and follow along with all the coursework, I recognize that I may not have succeeded completely, and as such, I must take at least part of the blame for this shortcoming.

  However, I also feel that the introduction we have received on WebGL has been lacking. In particular, there has not been enough information on how things like binding of textures, usage of shader programs, etc. affect the GL instance and how to properly context switch between them. Furhermore, the information handed out in relation to the assignment itself (including the links to relevant materials) seemed to lack a bit of information. While the

  The assignment states to use the data type ~gl.UNSIGNED_INT_24_8~ for the texture. However, despite spending a lot of time looking for resources I was unable to find any that showed how to use this. The data type was mentioned several times, including in [[https://developer.mozilla.org/en-US/docs/Web/API/WEBGL_depth_texture][MDN's WebGL docs]] and on [[https://webgl2fundamentals.org/webgl/lessons/webgl-data-textures.html][WebGLFundamentals]], but neither those nor any other resources I came across have any examples on how to use it or using WebGLs depth textures for shadow mapping. From my understanding, using these depth textures and said data type would allow a simplification of the render texture where, instead of having a color texture and a depth texture, you could have simply one texture made specifically for depth measuring which takes care of all of this for you. Now, it's not much more code to do it the long way, but it does add a bit of complexity and makes the whole concept less clear.

  Once I had managed to render to the texture and could confirm that it looked correct by rendering to the canvas instead of to the texture, the next thing was displaying the shadows correctly. In this I faced several challenges, of which the one that took me the longest to solve was how to make the shadows not be affected by the position and rotation of the camera. In the end I realized I had to multiply the lightModelViewMatrix by the camera's rotation matrix to make the shadows appear in the right spot.

  Dimensions of the target texture. This is an area where I struggled to find any good information, but from what I could find, it seems the standard is to make it square. The larger you make it, the more information it can hold and the smoother your shadows will look due to the increased resolution that comes with the larger size. Naturally, this is a point where you trade performance for visual quality, but for keeping downtime to a minimum, I went with 1024x1024, which gives me fairly smooth shadows and still acceptable performance on a mid-range laptop.

  There was also a fair amount of confusion relating to the orthographic projection matrix to be used for the light projection. In particular what values would be appropriate for the corners, and the near and far values. In the end it became a case of trial and error: finding something that would be able to capture the whole scene without getting too blurry because it's too far out. The ideal way to solve this would probably be to calculate how much has to be shown on a case by case basis and then rendering just the required amount, so that when the camera approaches an object and gets closer, the level of detail on the shadows would increase.

**  Known bugs and probable causes
   There are a couple issues with my current solution

**  Testing methods utilized
   While I am very much an avid proponent of testing, there was no formal or rigorous testing used as part of this project. This is due in part to the fact that testing graphics is inherently more difficult as it can often be hard to test visuals, and due in part to the fact that WebGL is a very stateful system, where setting up test cases and assertions can be very difficult.

That said, one point where tests could have been very useful is in matrix multiplication and model transformations. If you knew what you would want to end up with, you could have set up a test case and written functions and refined them until they gave the desired output. However, this would require a very good understanding of exactly where you wanted to go and it sounds more like a tool for making sure your calculations and transformations are correct. That said, broken up into small enough functions, this could have been a good way to assert that transformations are correct and to detect potential regressions.

Furthermore, as my knowledge of WebGL is still very basic, the entire exercise has been in the realm some may describe 'exploratory programming', where you don't really know what you're going to end up with and how you're going to get there, but you do have an idea of the rough outlines of things. At this level, I would argue that proper testing is still more of an overhead than a boon. Once a proper architecture is established and a solid understanding of the system is in place, however, erecting a test suite would be very beneficial.